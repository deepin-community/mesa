From 16af95c27ae4fb773ea2683f50baa519fd29a78e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michel=20D=C3=A4nzer?= <mdaenzer@redhat.com>
Date: Thu, 19 Aug 2021 16:03:03 +0200
Subject: [PATCH 1/7] loader/dri3: Clean up dri3_find_back logic

No need to go through the loop again for allocating a new buffer.

Part-of: <https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/18269>
---
 src/loader/loader_dri3_helper.c | 19 ++++++++++++++-----
 1 file changed, 14 insertions(+), 5 deletions(-)

diff --git a/src/loader/loader_dri3_helper.c b/src/loader/loader_dri3_helper.c
index fc043bd0533..53b30d23261 100644
--- a/src/loader/loader_dri3_helper.c
+++ b/src/loader/loader_dri3_helper.c
@@ -726,6 +726,7 @@ dri3_find_back(struct loader_dri3_drawable *draw, bool prefer_a_different)
     */
    int current_back_id = draw->cur_back;
    for (;;) {
+      /* Find idle buffer or unallocated slot */
       for (b = 0; b < num_to_consider; b++) {
          int id = LOADER_DRI3_BACK_ID((b + draw->cur_back) % draw->cur_num_back);
          struct loader_dri3_buffer *buffer = draw->buffers[id];
@@ -738,15 +739,23 @@ dri3_find_back(struct loader_dri3_drawable *draw, bool prefer_a_different)
          }
       }
 
+      /* No idle buffer, allocate another one if possible */
       if (num_to_consider < max_num) {
-         num_to_consider = ++draw->cur_num_back;
-      } else if (prefer_a_different) {
-         prefer_a_different = false;
-      } else if (!dri3_wait_for_event_locked(draw, NULL)) {
+         b = LOADER_DRI3_BACK_ID(draw->cur_num_back++);
+         draw->cur_back = b;
          mtx_unlock(&draw->mtx);
-         return -1;
+         return b;
       }
+
+      /* Prefer re-using the same buffer over blocking */
+      if (prefer_a_different)
+         prefer_a_different = false;
+      else if (!dri3_wait_for_event_locked(draw, NULL))
+         break;
    }
+
+   mtx_unlock(&draw->mtx);
+   return -1;
 }
 
 static xcb_gcontext_t
-- 
2.40.0

