From 2057faa9c6f7dff2d0d2c7dd067077ed49e19363 Mon Sep 17 00:00:00 2001
From: Brendan King <Brendan.King@imgtec.com>
Date: Thu, 17 Jun 2021 17:17:07 +0100
Subject: [PATCH 54/65] vulkan/wsi: make the display FD available

Pass the display FD to the Vulkan image create and memory
allocation functions when allocating swapchain images.

The wl_drm interface code has been partially restored, in order
to obtain the display FD from the compositor.
---
 src/vulkan/wsi/meson.build          |   2 +
 src/vulkan/wsi/wsi_common.c         |  10 ++-
 src/vulkan/wsi/wsi_common.h         |  14 ++++
 src/vulkan/wsi/wsi_common_display.c |   3 +-
 src/vulkan/wsi/wsi_common_drm.c     |  25 +++++-
 src/vulkan/wsi/wsi_common_private.h |   6 ++
 src/vulkan/wsi/wsi_common_wayland.c | 126 ++++++++++++++++++++++++++--
 src/vulkan/wsi/wsi_common_win32.c   |   2 +-
 src/vulkan/wsi/wsi_common_x11.c     |  25 +++++-
 9 files changed, 197 insertions(+), 16 deletions(-)

diff --git a/src/vulkan/wsi/meson.build b/src/vulkan/wsi/meson.build
index d35a3626a77..794f2a48445 100644
--- a/src/vulkan/wsi/meson.build
+++ b/src/vulkan/wsi/meson.build
@@ -31,6 +31,8 @@ endif
 if with_platform_wayland
   files_vulkan_wsi += files('wsi_common_wayland.c')
   files_vulkan_wsi += [
+    wayland_drm_client_protocol_h,
+    wayland_drm_protocol_c,
     linux_dmabuf_unstable_v1_client_protocol_h,
     linux_dmabuf_unstable_v1_protocol_c,
   ]
diff --git a/src/vulkan/wsi/wsi_common.c b/src/vulkan/wsi/wsi_common.c
index ab676658f5c..ba448860f01 100644
--- a/src/vulkan/wsi/wsi_common.c
+++ b/src/vulkan/wsi/wsi_common.c
@@ -357,6 +357,7 @@ VkResult
 wsi_configure_image(const struct wsi_swapchain *chain,
                     const VkSwapchainCreateInfoKHR *pCreateInfo,
                     VkExternalMemoryHandleTypeFlags handle_types,
+                    int display_fd,
                     struct wsi_image_info *info)
 {
    memset(info, 0, sizeof(*info));
@@ -411,6 +412,12 @@ wsi_configure_image(const struct wsi_swapchain *chain,
    };
    __vk_append_struct(&info->create, &info->wsi);
 
+   info->wsi2 = (struct wsi_image_create_info2) {
+      .sType = VK_STRUCTURE_TYPE_WSI_IMAGE_CREATE_INFO2_MESA,
+      .display_fd = display_fd,
+   };
+   __vk_append_struct(&info->create, &info->wsi2);
+
    if (pCreateInfo->flags & VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR) {
       info->create.flags |= VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT |
                             VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR;
@@ -465,6 +472,7 @@ VkResult
 wsi_create_image(const struct wsi_swapchain *chain,
                  const struct wsi_image_info *info,
                  bool host_visible,
+                 int display_fd,
                  struct wsi_image *image)
 {
    const struct wsi_device *wsi = chain->wsi;
@@ -479,7 +487,7 @@ wsi_create_image(const struct wsi_swapchain *chain,
    if (result != VK_SUCCESS)
       goto fail;
 
-   result = info->create_mem(chain, info, host_visible, image);
+   result = info->create_mem(chain, info, host_visible, display_fd, image);
    if (result != VK_SUCCESS)
       goto fail;
 
diff --git a/src/vulkan/wsi/wsi_common.h b/src/vulkan/wsi/wsi_common.h
index e565378ccfb..285d280bd09 100644
--- a/src/vulkan/wsi/wsi_common.h
+++ b/src/vulkan/wsi/wsi_common.h
@@ -46,6 +46,8 @@ extern const struct vk_device_entrypoint_table wsi_device_entrypoints;
 #define VK_STRUCTURE_TYPE_WSI_MEMORY_ALLOCATE_INFO_MESA (VkStructureType)1000001003
 #define VK_STRUCTURE_TYPE_WSI_SURFACE_SUPPORTED_COUNTERS_MESA (VkStructureType)1000001005
 #define VK_STRUCTURE_TYPE_WSI_MEMORY_SIGNAL_SUBMIT_INFO_MESA (VkStructureType)1000001006
+#define VK_STRUCTURE_TYPE_WSI_IMAGE_CREATE_INFO2_MESA (VkStructureType)1000001007
+#define VK_STRUCTURE_TYPE_WSI_MEMORY_ALLOCATE_INFO2_MESA (VkStructureType)1000001008
 
 /* This is always chained to VkImageCreateInfo when a wsi image is created.
  * It indicates that the image can be transitioned to/from
@@ -82,6 +84,18 @@ struct wsi_memory_signal_submit_info {
     VkDeviceMemory memory;
 };
 
+struct wsi_image_create_info2 {
+    VkStructureType sType;
+    const void *pNext;
+    int display_fd;
+};
+
+struct wsi_memory_allocate_info2 {
+    VkStructureType sType;
+    const void *pNext;
+    int display_fd;
+};
+
 struct wsi_interface;
 
 struct driOptionCache;
diff --git a/src/vulkan/wsi/wsi_common_display.c b/src/vulkan/wsi/wsi_common_display.c
index 2c7622630d5..8a678f03358 100644
--- a/src/vulkan/wsi/wsi_common_display.c
+++ b/src/vulkan/wsi/wsi_common_display.c
@@ -1057,7 +1057,7 @@ wsi_display_image_init(VkDevice device_h,
       return VK_ERROR_DEVICE_LOST;
 
    VkResult result = wsi_create_image(&chain->base, &chain->base.image_info,
-                                      false, &image->base);
+                                      false, wsi->fd, &image->base);
    if (result != VK_SUCCESS)
       return result;
 
@@ -1940,6 +1940,7 @@ wsi_display_surface_create_swapchain(
    result = wsi_configure_native_image(&chain->base, create_info,
                                        0, NULL, NULL,
                                        NULL /* alloc_shm */,
+                                       wsi->fd,
                                        &chain->base.image_info);
    if (result != VK_SUCCESS) {
       vk_free(allocator, chain);
diff --git a/src/vulkan/wsi/wsi_common_drm.c b/src/vulkan/wsi/wsi_common_drm.c
index b1c4b2625c2..29e1b8f2e5f 100644
--- a/src/vulkan/wsi/wsi_common_drm.c
+++ b/src/vulkan/wsi/wsi_common_drm.c
@@ -145,6 +145,7 @@ static VkResult
 wsi_create_native_image_mem(const struct wsi_swapchain *chain,
                             const struct wsi_image_info *info,
                             bool host_visible,
+                            int display_fd,
                             struct wsi_image *image);
 
 VkResult
@@ -155,6 +156,7 @@ wsi_configure_native_image(const struct wsi_swapchain *chain,
                            const uint64_t *const *modifiers,
                            uint8_t *(alloc_shm)(struct wsi_image *image,
                                                 unsigned size),
+                           int display_fd,
                            struct wsi_image_info *info)
 {
    const struct wsi_device *wsi = chain->wsi;
@@ -163,7 +165,8 @@ wsi_configure_native_image(const struct wsi_swapchain *chain,
       wsi->sw ? VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT :
                 VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT;
 
-   VkResult result = wsi_configure_image(chain, pCreateInfo, handle_type, info);
+   VkResult result = wsi_configure_image(chain, pCreateInfo, handle_type,
+                                         display_fd, info);
    if (result != VK_SUCCESS)
       return result;
 
@@ -294,6 +297,7 @@ static VkResult
 wsi_create_native_image_mem(const struct wsi_swapchain *chain,
                             const struct wsi_image_info *info,
                             bool host_visible,
+                            int display_fd,
                             struct wsi_image *image)
 {
    const struct wsi_device *wsi = chain->wsi;
@@ -320,9 +324,14 @@ wsi_create_native_image_mem(const struct wsi_swapchain *chain,
       .pNext = NULL,
       .implicit_sync = true,
    };
+   const struct wsi_memory_allocate_info2 memory_wsi_info2 = {
+      .sType = VK_STRUCTURE_TYPE_WSI_MEMORY_ALLOCATE_INFO2_MESA,
+      .pNext = &memory_wsi_info,
+      .display_fd = display_fd,
+   };
    const VkExportMemoryAllocateInfo memory_export_info = {
       .sType = VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO,
-      .pNext = &memory_wsi_info,
+      .pNext = &memory_wsi_info2,
       .handleTypes = wsi->sw ? VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT :
       VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT,
    };
@@ -440,6 +449,7 @@ static VkResult
 wsi_create_prime_image_mem(const struct wsi_swapchain *chain,
                            const struct wsi_image_info *info,
                            bool host_visible,
+                           int display_fd,
                            struct wsi_image *image)
 {
    const struct wsi_device *wsi = chain->wsi;
@@ -474,9 +484,14 @@ wsi_create_prime_image_mem(const struct wsi_swapchain *chain,
       .pNext = NULL,
       .implicit_sync = true,
    };
+   const struct wsi_memory_allocate_info2 memory_wsi_info2 = {
+      .sType = VK_STRUCTURE_TYPE_WSI_MEMORY_ALLOCATE_INFO2_MESA,
+      .pNext = &memory_wsi_info,
+      .display_fd = display_fd,
+   };
    const VkExportMemoryAllocateInfo prime_memory_export_info = {
       .sType = VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO,
-      .pNext = &memory_wsi_info,
+      .pNext = &memory_wsi_info2,
       .handleTypes = VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT,
    };
    const VkMemoryDedicatedAllocateInfo prime_memory_dedicated_info = {
@@ -610,10 +625,12 @@ VkResult
 wsi_configure_prime_image(UNUSED const struct wsi_swapchain *chain,
                           const VkSwapchainCreateInfoKHR *pCreateInfo,
                           bool use_modifier,
+                          int display_fd,
                           struct wsi_image_info *info)
 {
    VkResult result = wsi_configure_image(chain, pCreateInfo,
-                                         0 /* handle_types */, info);
+                                         0 /* handle_types */,
+                                         display_fd, info);
    if (result != VK_SUCCESS)
       return result;
 
diff --git a/src/vulkan/wsi/wsi_common_private.h b/src/vulkan/wsi/wsi_common_private.h
index b5ffeb24bce..7bbf3b2683a 100644
--- a/src/vulkan/wsi/wsi_common_private.h
+++ b/src/vulkan/wsi/wsi_common_private.h
@@ -32,6 +32,7 @@ struct wsi_swapchain;
 struct wsi_image_info {
    VkImageCreateInfo create;
    struct wsi_image_create_info wsi;
+   struct wsi_image_create_info2 wsi2;
    VkExternalMemoryImageCreateInfo ext_mem;
    VkImageFormatListCreateInfoKHR format_list;
    VkImageDrmFormatModifierListCreateInfoEXT drm_mod_list;
@@ -52,6 +53,7 @@ struct wsi_image_info {
    VkResult (*create_mem)(const struct wsi_swapchain *chain,
                           const struct wsi_image_info *info,
                           bool host_visible,
+                          int display_fd,
                           struct wsi_image *image);
 
    VkResult (*finish_create)(const struct wsi_swapchain *chain,
@@ -140,18 +142,21 @@ wsi_configure_native_image(const struct wsi_swapchain *chain,
                            const uint64_t *const *modifiers,
                            uint8_t *(alloc_shm)(struct wsi_image *image,
                                                 unsigned size),
+                           int display_fd,
                            struct wsi_image_info *info);
 
 VkResult
 wsi_configure_prime_image(UNUSED const struct wsi_swapchain *chain,
                           const VkSwapchainCreateInfoKHR *pCreateInfo,
                           bool use_modifier,
+                          int display_fd,
                           struct wsi_image_info *info);
 
 VkResult
 wsi_configure_image(const struct wsi_swapchain *chain,
                     const VkSwapchainCreateInfoKHR *pCreateInfo,
                     VkExternalMemoryHandleTypeFlags handle_types,
+                    int display_fd,
                     struct wsi_image_info *info);
 void
 wsi_destroy_image_info(const struct wsi_swapchain *chain,
@@ -160,6 +165,7 @@ VkResult
 wsi_create_image(const struct wsi_swapchain *chain,
                  const struct wsi_image_info *info,
                  bool host_visible,
+                 int display_fd,
                  struct wsi_image *image);
 void
 wsi_destroy_image(const struct wsi_swapchain *chain,
diff --git a/src/vulkan/wsi/wsi_common_wayland.c b/src/vulkan/wsi/wsi_common_wayland.c
index c7fffae03fd..324bd94ad97 100644
--- a/src/vulkan/wsi/wsi_common_wayland.c
+++ b/src/vulkan/wsi/wsi_common_wayland.c
@@ -32,6 +32,8 @@
 #include <pthread.h>
 #include <poll.h>
 #include <sys/mman.h>
+#include <fcntl.h>
+#include <xf86drm.h>
 
 #include "drm-uapi/drm_fourcc.h"
 
@@ -65,12 +67,15 @@ struct wsi_wl_display {
    struct wl_event_queue *                      queue;
 
    struct wl_shm *                              wl_shm;
+   struct wl_drm *                              wl_drm;
    struct zwp_linux_dmabuf_v1 *                 wl_dmabuf;
 
    struct wsi_wayland *wsi_wl;
 
    /* Formats populated by zwp_linux_dmabuf_v1 or wl_shm interfaces */
    struct u_vector                              formats;
+   int                                          fd;
+   bool                                         authenticated;
 
    /* Only used for displays created by wsi_wl_display_create */
    uint32_t                                     refcount;
@@ -472,6 +477,79 @@ wl_shm_format_for_vk_format(VkFormat vk_format, bool alpha)
    }
 }
 
+static int
+open_display_device(const char *name)
+{
+   int fd;
+
+#ifdef O_CLOEXEC
+   fd = open(name, O_RDWR | O_CLOEXEC);
+   if (fd != -1 || errno != EINVAL) {
+      return fd;
+   }
+#endif
+
+   fd = open(name, O_RDWR);
+   if (fd != -1) {
+      long flags = fcntl(fd, F_GETFD);
+
+      if (flags != -1) {
+         if (!fcntl(fd, F_SETFD, flags | FD_CLOEXEC))
+             return fd;
+      }
+      close (fd);
+   }
+
+   return -1;
+}
+
+static void
+drm_handle_device(void *data, struct wl_drm *drm, const char *name)
+{
+   struct wsi_wl_display *display = data;
+   const int fd = open_display_device(name);
+
+   if (fd != -1) {
+      if (drmGetNodeTypeFromFd(fd) != DRM_NODE_RENDER) {
+         drm_magic_t magic;
+
+         if (drmGetMagic(fd, &magic)) {
+            close(fd);
+	    return;
+         }
+	 wl_drm_authenticate(drm, magic);
+      } else {
+         display->authenticated = true;
+      }
+      display->fd = fd;
+   }
+}
+
+static void
+drm_handle_format(void *data, struct wl_drm *drm, uint32_t wl_format)
+{
+}
+
+static void
+drm_handle_authenticated(void *data, struct wl_drm *drm)
+{
+   struct wsi_wl_display *display = data;
+
+   display->authenticated = true;
+}
+
+static void
+drm_handle_capabilities(void *data, struct wl_drm *drm, uint32_t capabilities)
+{
+}
+
+static const struct wl_drm_listener drm_listener = {
+   drm_handle_device,
+   drm_handle_format,
+   drm_handle_authenticated,
+   drm_handle_capabilities,
+};
+
 static void
 dmabuf_handle_format(void *data, struct zwp_linux_dmabuf_v1 *dmabuf,
                      uint32_t format)
@@ -524,6 +602,15 @@ registry_handle_global(void *data, struct wl_registry *registry,
       return;
    }
 
+   if (strcmp(interface, "wl_drm") == 0) {
+      assert(display->wl_drm == NULL);
+      assert(version >= 2);
+
+      display->wl_drm =
+         wl_registry_bind(registry, name, &wl_drm_interface, 2);
+      wl_drm_add_listener(display->drm.wl_drm, &drm_listener, display);
+   }
+
    if (strcmp(interface, "zwp_linux_dmabuf_v1") == 0 && version >= 3) {
       display->wl_dmabuf =
          wl_registry_bind(registry, name, &zwp_linux_dmabuf_v1_interface, 3);
@@ -553,12 +640,17 @@ wsi_wl_display_finish(struct wsi_wl_display *display)
    u_vector_finish(&display->formats);
    if (display->wl_shm)
       wl_shm_destroy(display->wl_shm);
+   if (display->wl_drm)
+      wl_drm_destroy(display->wl_drm);
    if (display->wl_dmabuf)
       zwp_linux_dmabuf_v1_destroy(display->wl_dmabuf);
    if (display->wl_display_wrapper)
       wl_proxy_wrapper_destroy(display->wl_display_wrapper);
    if (display->queue)
       wl_event_queue_destroy(display->queue);
+
+   if (display->fd != -1)
+      close(display->fd);
 }
 
 static VkResult
@@ -576,6 +668,7 @@ wsi_wl_display_init(struct wsi_wayland *wsi_wl,
    display->wsi_wl = wsi_wl;
    display->wl_display = wl_display;
    display->sw = sw;
+   display->fd = -1;
 
    display->queue = wl_display_create_queue(wl_display);
    if (!display->queue) {
@@ -601,25 +694,45 @@ wsi_wl_display_init(struct wsi_wayland *wsi_wl,
 
    wl_registry_add_listener(registry, &registry_listener, display);
 
-   /* Round-trip to get wl_shm and zwp_linux_dmabuf_v1 globals */
+   /* Round-trip to get wl_shm, wl_drm and zwp_linux_dmabuf_v1 globals */
    wl_display_roundtrip_queue(display->wl_display, display->queue);
    if (!display->wl_dmabuf && !display->wl_shm) {
       result = VK_ERROR_SURFACE_LOST_KHR;
       goto fail_registry;
    }
 
+   if (display->wl_dmabuf && !display->wl_drm) {
+      result = VK_ERROR_SURFACE_LOST_KHR;
+      goto fail_registry;
+   }
+
+   /* Round-trip to get display FD, formats and modifiers */
+   if (display->wl_drm || get_format_list)
+      wl_display_roundtrip_queue(display->wl_display, display->queue);
+
+   if (display->wl_drm && display->fd == -1) {
+      result = VK_ERROR_SURFACE_LOST_KHR;
+      goto fail_registry;
+   }
+
+   if (display->wl_drm) {
+      wl_display_roundtrip_queue(display->wl_display, display->queue);
+
+      if (!display->authenticated) {
+         result = VK_ERROR_SURFACE_LOST_KHR;
+         goto fail_registry;
+      }
+   }
+
    /* Caller doesn't expect us to query formats/modifiers, so return */
    if (!get_format_list)
       goto out;
 
-   /* Round-trip again to get formats and modifiers */
-   wl_display_roundtrip_queue(display->wl_display, display->queue);
-
    if (wsi_wl->wsi->force_bgra8_unorm_first) {
       /* Find BGRA8_UNORM in the list and swap it to the first position if we
        * can find it.  Some apps get confused if SRGB is first in the list.
        */
-      struct wsi_wl_format *first_fmt = u_vector_head(&display->formats);
+      struct wsi_wl_format *first_fmt = u_vector_tail(&display->formats);
       struct wsi_wl_format *f, tmp_fmt;
       f = find_format(&display->formats, VK_FORMAT_B8G8R8A8_UNORM);
       if (f) {
@@ -1148,7 +1261,7 @@ wsi_wl_image_init(struct wsi_wl_swapchain *chain,
    VkResult result;
 
    result = wsi_create_image(&chain->base, &chain->base.image_info,
-                             false, &image->base);
+                             false, display->fd, &image->base);
    if (result != VK_SUCCESS)
       return result;
 
@@ -1337,6 +1450,7 @@ wsi_wl_surface_create_swapchain(VkIcdSurfaceBase *icd_surface,
                                        &chain->num_drm_modifiers,
                                        &chain->drm_modifiers,
                                        NULL /* alloc_shm */,
+                                       chain->display->fd,
                                        &chain->base.image_info);
    if (result != VK_SUCCESS)
       goto fail;
diff --git a/src/vulkan/wsi/wsi_common_win32.c b/src/vulkan/wsi/wsi_common_win32.c
index 9c4acd8d7c2..4aeb8e5387e 100644
--- a/src/vulkan/wsi/wsi_common_win32.c
+++ b/src/vulkan/wsi/wsi_common_win32.c
@@ -375,7 +375,7 @@ wsi_win32_image_init(VkDevice device_h,
    struct wsi_win32_swapchain *chain = (struct wsi_win32_swapchain *) drv_chain;
 
    VkResult result = wsi_create_image(&chain->base, &chain->base.image_info,
-                                      false, &image->base);
+                                      false, -1, &image->base);
    if (result != VK_SUCCESS)
       return result;
 
diff --git a/src/vulkan/wsi/wsi_common_x11.c b/src/vulkan/wsi/wsi_common_x11.c
index 7cf9e5416fe..26c894a1c71 100644
--- a/src/vulkan/wsi/wsi_common_x11.c
+++ b/src/vulkan/wsi/wsi_common_x11.c
@@ -1512,6 +1512,7 @@ static VkResult
 x11_image_init(VkDevice device_h, struct x11_swapchain *chain,
                const VkSwapchainCreateInfoKHR *pCreateInfo,
                const VkAllocationCallbacks* pAllocator,
+               int display_fd,
                struct x11_image *image)
 {
    xcb_void_cookie_t cookie;
@@ -1520,7 +1521,7 @@ x11_image_init(VkDevice device_h, struct x11_swapchain *chain,
    int fence_fd;
 
    result = wsi_create_image(&chain->base, &chain->base.image_info,
-                             chain->base.wsi->sw, &image->base);
+                             chain->base.wsi->sw, display_fd, &image->base);
    if (result != VK_SUCCESS)
       return result;
 
@@ -1957,16 +1958,26 @@ x11_surface_create_swapchain(VkIcdSurfaceBase *icd_surface,
                                  modifiers, num_modifiers, &num_tranches,
                                  pAllocator);
 
+   int display_fd = -1;
+   if (!wsi_device->sw) {
+      xcb_screen_iterator_t screen_iter =
+         xcb_setup_roots_iterator(xcb_get_setup(conn));
+      xcb_screen_t *screen = screen_iter.data;
+
+      display_fd = wsi_dri3_open(conn, screen->root, None);
+   }
+
    if (chain->base.use_prime_blit) {
       bool use_modifier = num_tranches > 0;
       result = wsi_configure_prime_image(&chain->base, pCreateInfo,
-                                         use_modifier,
+                                         use_modifier, display_fd,
                                          &chain->base.image_info);
    } else {
       result = wsi_configure_native_image(&chain->base, pCreateInfo,
                                           num_tranches, num_modifiers,
                                           (const uint64_t *const *)modifiers,
                                           chain->has_mit_shm ? &alloc_shm : NULL,
+                                          display_fd,
                                           &chain->base.image_info);
    }
    if (result != VK_SUCCESS)
@@ -1975,11 +1986,16 @@ x11_surface_create_swapchain(VkIcdSurfaceBase *icd_surface,
    uint32_t image = 0;
    for (; image < chain->base.image_count; image++) {
       result = x11_image_init(device, chain, pCreateInfo, pAllocator,
-                              &chain->images[image]);
+                              display_fd, &chain->images[image]);
       if (result != VK_SUCCESS)
          goto fail_init_images;
    }
 
+   if (display_fd >= 0) {
+      close(display_fd);
+      display_fd = -1;
+   }
+
    /* Initialize queues for images in our swapchain. Possible queues are:
     * - Present queue: for images sent to the X server but not yet presented.
     * - Acquire queue: for images already presented but not yet released by the
@@ -2058,6 +2074,9 @@ fail_modifiers:
    for (int i = 0; i < ARRAY_SIZE(modifiers); i++)
       vk_free(pAllocator, modifiers[i]);
 
+   if (display_fd >= 0)
+     close(display_fd);
+
 fail_register:
    xcb_unregister_for_special_event(chain->conn, chain->special_event);
 
-- 
2.25.1

